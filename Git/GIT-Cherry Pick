**Что такое cherry pick?**
Это команда, которая при наличии нескольких коммитов в одной ветке может применять изменения отдельного выбранного коммита или нескольких коммитов уже к другой ветке. При этом требуется "чистое" состояние рабочей директории. Что же происходит по шагам (согласно каноничному учебнику GIT-SCM)?

Текущая ветка и указатель HEAD остаются на точке последнего успешного коммита;
Создается указатель CHERRY_PICK_HEAD на точке коммита, начиная с которого изменения сложно применить;
Пути, по которым применяются изменения, обновляются как в файле индекса, так и в рабочем дереве;
Для конфликтующих путей в индексный файл пишется до 3 версий записи .
Это всё сложнооо.... Надо попроще. Если совсем кратко, то команда git cherry-pick <id коммита> забирает конкретный коммит из одной ветки и вставляет его в текущую ветку,

Рассмотрим ситуацию, когда эта команда реально может быть полезна. Допустим, ты разрабатываешь новые фичи в своей ветке проекта к будущему спринту. Как только код готов - ты его пушишь в ветку develop и открываешь на следующем публичном релизе, когда все изменения будут протестированы. Но заказчик недоволен частью внесенных изменений и просит включить в релиз только некоторые из них. Так как не все уже имплементированные фичи были приняты для следующего релиза, git merge или git rebase не дадут нужного результата, так как тогда будут включены все изменения начиная с предыдущего спринта.

И тут - тадаам! на помощь приходит cherry pick - он позволяет гранулярно извлекать уже примененные коммиты из ветки develop и применить в ветке master.

Кстати да, есть git diff, но, в отличие от git diff, c cherry pick намного легче избегать конфликтов слияния.

В общем, git cherry-pick полезен, когда:

надо фиксить отдельные баги в проде, при том что они были отловлены и пофиксены в ветке develop с отдельными коммитами.
нельзя слить всю ветку из-за несовместимых версий кода в разных ветках.
надо применить отдельные изменения, которые были сделаны в дочерней ветке, без изменения всей ветки

**Примеры команд с пояснениями**
Примеры опять же приведены из GIT-SCM, поэтому могут для не очень опытных пользователей git быть не совсем понятными и очевидными. 
Но попробовать разобраться с ними будет полезно.

_git cherry-pick master_
Применяет изменения, зафиксированные последним коммитом в ветке master и создает новый коммит с этими изменениями в той ветке,
где вы сейчас находитесь.

_git cherry-pick ..master_
_git cherry-pick ^HEAD master_
Применяет изменения из всех коммитов - предшественников (ancestors) ветки master, но не ветки, на которую указывает HEAD

_git cherry-pick maint next ^master_
_git cherry-pick maint master..next_
Применяет изменения из всех коммитов - предшественников ветки maint или next, но не ветки master либо ее предшественников.

_git cherry-pick master~4 master~2_
Применяет изменения между пятым и третьим коммитами ветки master, начиная с конца, и создает 2 новых коммита с этими изменениями

_git cherry-pick -n master~1 next_
Применяет к рабочей ветке и к индексу изменений изменения во втором с конца коммите ветки master и в последнем коммите ветки next,
но при этом не создает новых коммитов с этими изменениями.

_git cherry-pick --ff ..next_
Если история является линейной и ветка, на которую указывает HEAD, является предшественником ветки next, 
то обновить рабочую ветку и переместить указатель HEAD на next. 
Если же нет - то применить изменения из тех коммитов, которые в ветке next, исключая тот, на который указывает HEAD, 
к текущей ветке, создавая новый коммит для каждого нового изменения.

